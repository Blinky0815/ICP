<!-- HTML header for doxygen 1.8.9-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" href="favicon.png" type="image/x-icon"/>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>ICP: ICP Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="css/font-awesome.min.css" rel="stylesheet">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-57722192-1', 'auto');
  ga('send', 'pageview');
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" style="width: 100%;">
 <tbody>
 <tr style="height: 72px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ICP
   &#160;<span id="projectnumber">1.1.0</span>
   </div>
  </td>
  <td><a id="repo" href="https://github.com/pAIgn10/ICP"><i class="fa fa-github"></i><span id="repo-text">&nbsp;Hosted by GitHub</span></a></td>
  <td id="projectlogo"><a href="http://paign10.me"><img alt="Logo" src="logo.png"/></a></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">ICP Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Offers functions that are serial <code>CPU</code> implementations of the relevant algorithms in the <code>ICP</code> pipeline.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9d95ef3c59a6212d1b48db9e32b56447"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceICP.html#a9d95ef3c59a6212d1b48db9e32b56447">setProfilingFlag</a> (int argc, char **argv)</td></tr>
<tr class="memdesc:a9d95ef3c59a6212d1b48db9e32b56447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the command line arguments for the profiling flag, <code>--profiling</code>.  <a href="#a9d95ef3c59a6212d1b48db9e32b56447">More...</a><br /></td></tr>
<tr class="separator:a9d95ef3c59a6212d1b48db9e32b56447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05339f56ec69a7c51b5156fa20423208"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a05339f56ec69a7c51b5156fa20423208"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceICP.html#a05339f56ec69a7c51b5156fa20423208">nextPow2</a> (T num)</td></tr>
<tr class="memdesc:a05339f56ec69a7c51b5156fa20423208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first power of 2 greater than or equal to the input.  <a href="#a05339f56ec69a7c51b5156fa20423208">More...</a><br /></td></tr>
<tr class="separator:a05339f56ec69a7c51b5156fa20423208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ace22ea02516db047a1e6f65d75010"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a98ace22ea02516db047a1e6f65d75010"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceICP.html#a98ace22ea02516db047a1e6f65d75010">printBuffer</a> (const char *title, T *ptr, uint32_t width, uint32_t height)</td></tr>
<tr class="memdesc:a98ace22ea02516db047a1e6f65d75010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints an array of an integer type to standard output.  <a href="#a98ace22ea02516db047a1e6f65d75010">More...</a><br /></td></tr>
<tr class="separator:a98ace22ea02516db047a1e6f65d75010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d5cf5711f6b7bff8c5237870f0d60c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a42d5cf5711f6b7bff8c5237870f0d60c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceICP.html#a42d5cf5711f6b7bff8c5237870f0d60c">printBufferF</a> (const char *title, T *ptr, uint32_t width, uint32_t height, uint32_t prec)</td></tr>
<tr class="memdesc:a42d5cf5711f6b7bff8c5237870f0d60c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints an array of floating-point type to standard output.  <a href="#a42d5cf5711f6b7bff8c5237870f0d60c">More...</a><br /></td></tr>
<tr class="separator:a42d5cf5711f6b7bff8c5237870f0d60c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54738e9b590eb0c0339b24c7a0e4468c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a54738e9b590eb0c0339b24c7a0e4468c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceICP.html#a54738e9b590eb0c0339b24c7a0e4468c">cpuReduce</a> (T *in, T *out, uint32_t cols, uint32_t rows, std::function&lt; bool(T, T)&gt; func)</td></tr>
<tr class="memdesc:a54738e9b590eb0c0339b24c7a0e4468c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces each row of an array to a single element.  <a href="#a54738e9b590eb0c0339b24c7a0e4468c">More...</a><br /></td></tr>
<tr class="separator:a54738e9b590eb0c0339b24c7a0e4468c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272fb8e7670c828e2493fef2f95e3ab2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a272fb8e7670c828e2493fef2f95e3ab2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceICP.html#a272fb8e7670c828e2493fef2f95e3ab2">cpuReduceSum</a> (T *in, T *out, uint32_t cols, uint32_t rows)</td></tr>
<tr class="memdesc:a272fb8e7670c828e2493fef2f95e3ab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces each row of an array to a single element (sum).  <a href="#a272fb8e7670c828e2493fef2f95e3ab2">More...</a><br /></td></tr>
<tr class="separator:a272fb8e7670c828e2493fef2f95e3ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4cc9483770601085a66416da032de9e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab4cc9483770601085a66416da032de9e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceICP.html#ab4cc9483770601085a66416da032de9e">cpuInScan</a> (T *in, T *out, uint32_t width, uint32_t height)</td></tr>
<tr class="memdesc:ab4cc9483770601085a66416da032de9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an inclusive scan operation on the columns of an array.  <a href="#ab4cc9483770601085a66416da032de9e">More...</a><br /></td></tr>
<tr class="separator:ab4cc9483770601085a66416da032de9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c7716f7ca39aa1a790361dbf0df611"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a44c7716f7ca39aa1a790361dbf0df611"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceICP.html#a44c7716f7ca39aa1a790361dbf0df611">cpuExScan</a> (T *in, T *out, uint32_t width, uint32_t height)</td></tr>
<tr class="memdesc:a44c7716f7ca39aa1a790361dbf0df611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an exclusive scan operation on the columns of an array.  <a href="#a44c7716f7ca39aa1a790361dbf0df611">More...</a><br /></td></tr>
<tr class="separator:a44c7716f7ca39aa1a790361dbf0df611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaead918a49248420da7431be8318961"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adaead918a49248420da7431be8318961"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceICP.html#adaead918a49248420da7431be8318961">cpuICPLMs</a> (T *in, T *out)</td></tr>
<tr class="memdesc:adaead918a49248420da7431be8318961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Samples a point cloud for 16384 (128x128) landmarks.  <a href="#adaead918a49248420da7431be8318961">More...</a><br /></td></tr>
<tr class="separator:adaead918a49248420da7431be8318961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d364b3eb95b4f71bbc3958a69af8d3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae1d364b3eb95b4f71bbc3958a69af8d3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceICP.html#ae1d364b3eb95b4f71bbc3958a69af8d3">cpuICPReps</a> (T *in, T *out, uint32_t nr)</td></tr>
<tr class="memdesc:ae1d364b3eb95b4f71bbc3958a69af8d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Samples a set of 16384 (128x128) landmarks for representatives.  <a href="#ae1d364b3eb95b4f71bbc3958a69af8d3">More...</a><br /></td></tr>
<tr class="separator:ae1d364b3eb95b4f71bbc3958a69af8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9797ce2681e481edc52d02bff4097e27"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9797ce2681e481edc52d02bff4097e27"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceICP.html#a9797ce2681e481edc52d02bff4097e27">cpuICPWeights</a> (rbc_dist_id *D, T *W, cl_double *SW, uint32_t n)</td></tr>
<tr class="memdesc:a9797ce2681e481edc52d02bff4097e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes weights for pairs of points in the fixed and moving sets, and also reduces them to get their sum.  <a href="#a9797ce2681e481edc52d02bff4097e27">More...</a><br /></td></tr>
<tr class="separator:a9797ce2681e481edc52d02bff4097e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc82dd2a63db2b1b4143189d2ad846ac"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acc82dd2a63db2b1b4143189d2ad846ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceICP.html#acc82dd2a63db2b1b4143189d2ad846ac">cpuICPMean</a> (T *F, T *M, T *mean, uint32_t n)</td></tr>
<tr class="memdesc:acc82dd2a63db2b1b4143189d2ad846ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the mean on the xyz dimensions of the set of 8-D points.  <a href="#acc82dd2a63db2b1b4143189d2ad846ac">More...</a><br /></td></tr>
<tr class="separator:acc82dd2a63db2b1b4143189d2ad846ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ec007a2387003318f33fada3809f41"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa4ec007a2387003318f33fada3809f41"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceICP.html#aa4ec007a2387003318f33fada3809f41">cpuICPMeanWeighted</a> (T *F, T *M, T *MEAN, T *W, uint32_t n)</td></tr>
<tr class="memdesc:aa4ec007a2387003318f33fada3809f41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the weighted mean on the xyz dimensions of the set of 8-D points.  <a href="#aa4ec007a2387003318f33fada3809f41">More...</a><br /></td></tr>
<tr class="separator:aa4ec007a2387003318f33fada3809f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf067a6d5c8d36b2225cadfabbe0d86"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3cf067a6d5c8d36b2225cadfabbe0d86"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceICP.html#a3cf067a6d5c8d36b2225cadfabbe0d86">cpuICPDevs</a> (T *F, T *M, T *DF, T *DM, T *mean, uint32_t n)</td></tr>
<tr class="memdesc:a3cf067a6d5c8d36b2225cadfabbe0d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the deviations of a set of points from their mean.  <a href="#a3cf067a6d5c8d36b2225cadfabbe0d86">More...</a><br /></td></tr>
<tr class="separator:a3cf067a6d5c8d36b2225cadfabbe0d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe9c512ee1e31bc7386826c68e34398"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aabe9c512ee1e31bc7386826c68e34398"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceICP.html#aabe9c512ee1e31bc7386826c68e34398">cpuICPS</a> (T *DM, T *DF, T *S, uint32_t m, float c)</td></tr>
<tr class="memdesc:aabe9c512ee1e31bc7386826c68e34398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the S matrix and the constituents of the scale factor s.  <a href="#aabe9c512ee1e31bc7386826c68e34398">More...</a><br /></td></tr>
<tr class="separator:aabe9c512ee1e31bc7386826c68e34398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a160687193a9199828e562ff6c1bce725"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a160687193a9199828e562ff6c1bce725"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceICP.html#a160687193a9199828e562ff6c1bce725">cpuICPSw</a> (T *M, T *F, T *W, T *S, uint32_t m, float c)</td></tr>
<tr class="memdesc:a160687193a9199828e562ff6c1bce725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the S matrix and the constituents of the scale factor s.  <a href="#a160687193a9199828e562ff6c1bce725">More...</a><br /></td></tr>
<tr class="separator:a160687193a9199828e562ff6c1bce725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3869d1e841e3dc9df4f3885eccc9a4a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad3869d1e841e3dc9df4f3885eccc9a4a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceICP.html#ad3869d1e841e3dc9df4f3885eccc9a4a">cross_product</a> (T *a, T *b, T *c)</td></tr>
<tr class="memdesc:ad3869d1e841e3dc9df4f3885eccc9a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a cross product.  <a href="#ad3869d1e841e3dc9df4f3885eccc9a4a">More...</a><br /></td></tr>
<tr class="separator:ad3869d1e841e3dc9df4f3885eccc9a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a456171bffd4bb19841dce6d69ddee80c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a456171bffd4bb19841dce6d69ddee80c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceICP.html#a456171bffd4bb19841dce6d69ddee80c">cpuICPTransformQ</a> (T *M, T *tM, T *D, uint32_t m)</td></tr>
<tr class="memdesc:a456171bffd4bb19841dce6d69ddee80c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a homogeneous transformation on a set of points using a quaternion and a translation vector.  <a href="#a456171bffd4bb19841dce6d69ddee80c">More...</a><br /></td></tr>
<tr class="separator:a456171bffd4bb19841dce6d69ddee80c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8082f6bf62e87c39f05572a4aa144a94"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8082f6bf62e87c39f05572a4aa144a94"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceICP.html#a8082f6bf62e87c39f05572a4aa144a94">cpuICPTransformQ2</a> (T *M, T *tM, T *D, uint32_t m)</td></tr>
<tr class="memdesc:a8082f6bf62e87c39f05572a4aa144a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a homogeneous transformation on a set of points using a quaternion and a translation vector.  <a href="#a8082f6bf62e87c39f05572a4aa144a94">More...</a><br /></td></tr>
<tr class="separator:a8082f6bf62e87c39f05572a4aa144a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80286462f37b3212d39cef7d621aea4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab80286462f37b3212d39cef7d621aea4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceICP.html#ab80286462f37b3212d39cef7d621aea4">cpuICPTransformM</a> (T *M, T *tM, T *D, uint32_t m)</td></tr>
<tr class="memdesc:ab80286462f37b3212d39cef7d621aea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a homogeneous transformation on a set of points using a transformation matrix.  <a href="#ab80286462f37b3212d39cef7d621aea4">More...</a><br /></td></tr>
<tr class="separator:ab80286462f37b3212d39cef7d621aea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90bc24bcb394c88bad6507c86a7ce75"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae90bc24bcb394c88bad6507c86a7ce75"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceICP.html#ae90bc24bcb394c88bad6507c86a7ce75">cpuLength</a> (T *x)</td></tr>
<tr class="memdesc:ae90bc24bcb394c88bad6507c86a7ce75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the vector length ( \(\ell_2\) norm).  <a href="#ae90bc24bcb394c88bad6507c86a7ce75">More...</a><br /></td></tr>
<tr class="separator:ae90bc24bcb394c88bad6507c86a7ce75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770debc8268ca52d659062af6ec62be7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a770debc8268ca52d659062af6ec62be7"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceICP.html#a770debc8268ca52d659062af6ec62be7">cpuDistance</a> (T *x1, T *x2)</td></tr>
<tr class="memdesc:a770debc8268ca52d659062af6ec62be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the vector distance ( \(\ell_2\) norm).  <a href="#a770debc8268ca52d659062af6ec62be7">More...</a><br /></td></tr>
<tr class="separator:a770debc8268ca52d659062af6ec62be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3ccbacdf0f5e3a80ecf983f8bcfdc2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acc3ccbacdf0f5e3a80ecf983f8bcfdc2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceICP.html#acc3ccbacdf0f5e3a80ecf983f8bcfdc2">cpuNormalize</a> (T *x)</td></tr>
<tr class="memdesc:acc3ccbacdf0f5e3a80ecf983f8bcfdc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes a vector.  <a href="#acc3ccbacdf0f5e3a80ecf983f8bcfdc2">More...</a><br /></td></tr>
<tr class="separator:acc3ccbacdf0f5e3a80ecf983f8bcfdc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca24a6fb24b444ed70b6af159966346"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acca24a6fb24b444ed70b6af159966346"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceICP.html#acca24a6fb24b444ed70b6af159966346">cpuProd</a> (T *N, T *x, T *x_new)</td></tr>
<tr class="memdesc:acca24a6fb24b444ed70b6af159966346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a matrix-vector product, \( x_{new}=Nx \).  <a href="#acca24a6fb24b444ed70b6af159966346">More...</a><br /></td></tr>
<tr class="separator:acca24a6fb24b444ed70b6af159966346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af79f8c894df09dc605b418d1c7318b6b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af79f8c894df09dc605b418d1c7318b6b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceICP.html#af79f8c894df09dc605b418d1c7318b6b">cpuICPPowerMethod</a> (T *Sij, T *means, T *Tk)</td></tr>
<tr class="memdesc:af79f8c894df09dc605b418d1c7318b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the quantities that represent the incremental development in the transformation estimation in iteration <code>k</code>.  <a href="#af79f8c894df09dc605b418d1c7318b6b">More...</a><br /></td></tr>
<tr class="separator:af79f8c894df09dc605b418d1c7318b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aedc8d924686541acd7305d6e5f71dba9"><td class="memItemLeft" align="right" valign="top">std::function&lt; unsigned char()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceICP.html#aedc8d924686541acd7305d6e5f71dba9">rNum_0_255</a> = std::bind (distribution1, generator)</td></tr>
<tr class="memdesc:aedc8d924686541acd7305d6e5f71dba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uniform number generator in the range \([0, 255]\).  <a href="#aedc8d924686541acd7305d6e5f71dba9">More...</a><br /></td></tr>
<tr class="separator:aedc8d924686541acd7305d6e5f71dba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9318de7ad6e48e0abb3d805207ee8acd"><td class="memItemLeft" align="right" valign="top">std::function&lt; unsigned short()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceICP.html#a9318de7ad6e48e0abb3d805207ee8acd">rNum_0_10000</a> = std::bind (distribution2, generator)</td></tr>
<tr class="memdesc:a9318de7ad6e48e0abb3d805207ee8acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uniform number generator in the range \([0, 10000]\).  <a href="#a9318de7ad6e48e0abb3d805207ee8acd">More...</a><br /></td></tr>
<tr class="separator:a9318de7ad6e48e0abb3d805207ee8acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919f87189d50d0bb2eaebb70bff46963"><td class="memItemLeft" align="right" valign="top">std::function&lt; float()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceICP.html#a919f87189d50d0bb2eaebb70bff46963">rNum_R_0_1</a> = std::bind (distributionR1, generator)</td></tr>
<tr class="memdesc:a919f87189d50d0bb2eaebb70bff46963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uniform number generator in the range \([0.0, 1.0)\).  <a href="#a919f87189d50d0bb2eaebb70bff46963">More...</a><br /></td></tr>
<tr class="separator:a919f87189d50d0bb2eaebb70bff46963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a90297f1ab4ebb2505480351591a717"><td class="memItemLeft" align="right" valign="top">std::function&lt; float()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceICP.html#a4a90297f1ab4ebb2505480351591a717">rNum_R_1_255_E__6</a> = std::bind (distributionR2, generator)</td></tr>
<tr class="memdesc:a4a90297f1ab4ebb2505480351591a717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uniform number generator in the range \([1e-6, 255*1e-6)\).  <a href="#a4a90297f1ab4ebb2505480351591a717">More...</a><br /></td></tr>
<tr class="separator:a4a90297f1ab4ebb2505480351591a717"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Offers functions that are serial <code>CPU</code> implementations of the relevant algorithms in the <code>ICP</code> pipeline. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a770debc8268ca52d659062af6ec62be7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T ICP::cpuDistance </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the vector distance ( \(\ell_2\) norm). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to be handled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x1</td><td>4-vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x2</td><td>4-vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vector distance. </dd></dl>

</div>
</div>
<a class="anchor" id="a44c7716f7ca39aa1a790361dbf0df611"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ICP::cpuExScan </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs an exclusive scan operation on the columns of an array. </p>
<p>It is just a naive serial implementation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to be handled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>input data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>output (scan) data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>width of the array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>height of the array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3cf067a6d5c8d36b2225cadfabbe0d86"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ICP::cpuICPDevs </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>DF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>DM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the deviations of a set of points from their mean. </p>
<p>It is just a naive serial implementation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to be handled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>fixed set of 8-D elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>moving set of 8-D elements. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DM</td><td>array (moving set deviations) of 4-D elements. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DF</td><td>array (fixed set deviations) of 4-D elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mean</td><td>fixed and moving set means. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of points in the sets. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adaead918a49248420da7431be8318961"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ICP::cpuICPLMs </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Samples a point cloud for 16384 (128x128) landmarks. </p>
<p>It is just a naive serial implementation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to be handled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>input data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>output (LM) data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acc82dd2a63db2b1b4143189d2ad846ac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ICP::cpuICPMean </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the mean on the xyz dimensions of the set of 8-D points. </p>
<p>It is just a naive serial implementation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to be handled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>fixed set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>moving set. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mean</td><td>output data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of points in the array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa4ec007a2387003318f33fada3809f41"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ICP::cpuICPMeanWeighted </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>MEAN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the weighted mean on the xyz dimensions of the set of 8-D points. </p>
<p>It is just a naive serial implementation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to be handled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>fixed set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>moving set. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">MEAN</td><td>output data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">W</td><td>weights. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of points in the array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af79f8c894df09dc605b418d1c7318b6b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T ICP::cpuICPPowerMethod </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>Sij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>means</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>Tk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the quantities that represent the incremental development in the transformation estimation in iteration <code>k</code>. </p>
<p>It is just a naive serial implementation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to be handled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Sij</td><td>sums of products. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">means</td><td>fixed and moving set means. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Tk</td><td>the <b>unit quaternion</b> \( \dot{q_k} = q_w + q_x i + q_y j + q_z k = \left[ \begin{matrix} q_x &amp; q_y &amp; q_z &amp; q_w \end{matrix} \right]^T \), and the <b>translation vector</b> \( t_k=\left[ \begin{matrix} t_x &amp; t_y &amp; t_z &amp; 1 \end{matrix} \right]^T \). The scale is placed in the last element of the translation vector. That is, \( t_k = \left[ \begin{matrix} t_x &amp; t_y &amp; t_z &amp; s_k \end{matrix} \right]^T \). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae1d364b3eb95b4f71bbc3958a69af8d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ICP::cpuICPReps </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Samples a set of 16384 (128x128) landmarks for representatives. </p>
<p>It is just a naive serial implementation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to be handled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>input data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>output (LM) data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nr</td><td>number of representatives. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aabe9c512ee1e31bc7386826c68e34398"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ICP::cpuICPS </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>DM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>DF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the S matrix and the constituents of the scale factor s. </p>
<p>It is just a naive serial implementation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to be handled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">DM</td><td>input array (moving set deviations) of 4-D elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DF</td><td>input array (fixed set deviations) of 4-D elements. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td>output (sums of products) matrix S. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>number of points in the sets. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>scaling factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a160687193a9199828e562ff6c1bce725"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ICP::cpuICPSw </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the S matrix and the constituents of the scale factor s. </p>
<p>It is just a naive serial implementation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to be handled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>input array (moving set deviations) of 4-D elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>input array (fixed set deviations) of 4-D elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">W</td><td>input array (weights). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td>output (sums of products) matrix S. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>number of points in the sets. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>scaling factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab80286462f37b3212d39cef7d621aea4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ICP::cpuICPTransformM </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>tM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a homogeneous transformation on a set of points using a transformation matrix. </p>
<p>It is just a naive serial implementation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to be handled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>input array (set of points) of 8-D elements. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tM</td><td>output array (transformed points) of 8-D elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>transformation parameters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>number of points in the set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a456171bffd4bb19841dce6d69ddee80c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ICP::cpuICPTransformQ </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>tM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a homogeneous transformation on a set of points using a quaternion and a translation vector. </p>
<p>It is just a naive serial implementation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to be handled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>input array (set of points) of 8-D elements. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tM</td><td>output array (transformed points) of 8-D elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>transformation parameters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>number of points in the set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8082f6bf62e87c39f05572a4aa144a94"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ICP::cpuICPTransformQ2 </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>tM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a homogeneous transformation on a set of points using a quaternion and a translation vector. </p>
<p>It is just a naive serial implementation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to be handled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>input array (set of points) of 8-D elements. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tM</td><td>output array (transformed points) of 8-D elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>transformation parameters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>number of points in the set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9797ce2681e481edc52d02bff4097e27"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ICP::cpuICPWeights </td>
          <td>(</td>
          <td class="paramtype">rbc_dist_id *&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_double *&#160;</td>
          <td class="paramname"><em>SW</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes weights for pairs of points in the fixed and moving sets, and also reduces them to get their sum. </p>
<p>It is just a naive serial implementation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to be handled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>input data (distances). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W</td><td>output data (weights). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SW</td><td>output data (sum of weights). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of elements in the input array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab4cc9483770601085a66416da032de9e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ICP::cpuInScan </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs an inclusive scan operation on the columns of an array. </p>
<p>It is just a naive serial implementation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to be handled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>input data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>output (scan) data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>width of the array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>height of the array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae90bc24bcb394c88bad6507c86a7ce75"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T ICP::cpuLength </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the vector length ( \(\ell_2\) norm). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to be handled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>4-vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vector length. </dd></dl>

</div>
</div>
<a class="anchor" id="acc3ccbacdf0f5e3a80ecf983f8bcfdc2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ICP::cpuNormalize </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalizes a vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to be handled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>4-vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acca24a6fb24b444ed70b6af159966346"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ICP::cpuProd </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>x_new</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a matrix-vector product, \( x_{new}=Nx \). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to be handled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><code>4x4</code> matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>4-vector. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">x_new</td><td>4-vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a54738e9b590eb0c0339b24c7a0e4468c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ICP::cpuReduce </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(T, T)&gt;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduces each row of an array to a single element. </p>
<p>It is just a naive serial implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>input data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>output (reduced) data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cols</td><td>number of columns in the input array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rows</td><td>number of rows in the input array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>function supporting the requested operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a272fb8e7670c828e2493fef2f95e3ab2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ICP::cpuReduceSum </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduces each row of an array to a single element (sum). </p>
<p>It is just a naive serial implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>input data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>output (reduced) data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cols</td><td>number of columns in the input array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rows</td><td>number of rows in the input array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad3869d1e841e3dc9df4f3885eccc9a4a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ICP::cross_product </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a cross product. </p>
<p>It is just a naive serial implementation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to be handled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>first input vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>second input vector. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>output vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a05339f56ec69a7c51b5156fa20423208"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ICP::nextPow2 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first power of 2 greater than or equal to the input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>input number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first power of 2 &gt;= num. </dd></dl>

</div>
</div>
<a class="anchor" id="a98ace22ea02516db047a1e6f65d75010"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ICP::printBuffer </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>title</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints an array of an integer type to standard output. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to be printed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">title</td><td>legend for the output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>array that is to be displayed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>width of the array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>height of the array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a42d5cf5711f6b7bff8c5237870f0d60c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ICP::printBufferF </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>title</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>prec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints an array of floating-point type to standard output. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to be printed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">title</td><td>legend for the output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>array that is to be displayed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>width of the array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>height of the array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prec</td><td>the number of decimal places to print. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9d95ef3c59a6212d1b48db9e32b56447"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ICP::setProfilingFlag </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the command line arguments for the profiling flag, <code>--profiling</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">argc</td><td>command line argument count </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argv</td><td>command line arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A flag to indicate whether a command line argument for profiling was provided. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a9318de7ad6e48e0abb3d805207ee8acd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; unsigned short()&gt; ICP::rNum_0_10000 = std::bind (distribution2, generator)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uniform number generator in the range \([0, 10000]\). </p>

</div>
</div>
<a class="anchor" id="aedc8d924686541acd7305d6e5f71dba9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; unsigned char()&gt; ICP::rNum_0_255 = std::bind (distribution1, generator)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uniform number generator in the range \([0, 255]\). </p>

</div>
</div>
<a class="anchor" id="a919f87189d50d0bb2eaebb70bff46963"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; float()&gt; ICP::rNum_R_0_1 = std::bind (distributionR1, generator)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uniform number generator in the range \([0.0, 1.0)\). </p>

</div>
</div>
<a class="anchor" id="a4a90297f1ab4ebb2505480351591a717"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; float()&gt; ICP::rNum_R_1_255_E__6 = std::bind (distributionR2, generator)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uniform number generator in the range \([1e-6, 255*1e-6)\). </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 28 2015 22:01:02 for ICP by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
