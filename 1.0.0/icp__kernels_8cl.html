<!-- HTML header for doxygen 1.8.9-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" href="favicon.png" type="image/x-icon"/>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>ICP: icp_kernels.cl File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="css/font-awesome.min.css" rel="stylesheet">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-57722192-1', 'auto');
  ga('send', 'pageview');
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" style="width: 100%;">
 <tbody>
 <tr style="height: 72px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ICP
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
  <td><a id="repo" href="https://github.com/pAIgn10/ICP"><i class="fa fa-github"></i><span id="repo-text">&nbsp;Hosted by GitHub</span></a></td>
  <td id="projectlogo"><a href="http://paign10.me"><img alt="Logo" src="logo.png"/></a></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d3fd84b2e4114076d2551689812cf799.html">kernels</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">icp_kernels.cl File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Kernels for the <code>ICP</code> pipeline.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdist__id.html">dist_id</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct holding a value and a key.  <a href="structdist__id.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8d115c63e8e45d94ce44c4ec35c3448c"><td class="memItemLeft" align="right" valign="top">kernel void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icp__kernels_8cl.html#a8d115c63e8e45d94ce44c4ec35c3448c">getLMs</a> (global float4 *in, global float4 *out)</td></tr>
<tr class="memdesc:a8d115c63e8e45d94ce44c4ec35c3448c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Samples a point cloud for landmarks.  <a href="#a8d115c63e8e45d94ce44c4ec35c3448c">More...</a><br /></td></tr>
<tr class="separator:a8d115c63e8e45d94ce44c4ec35c3448c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5cf8330ab00e80d44513e3c4477418"><td class="memItemLeft" align="right" valign="top">kernel void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icp__kernels_8cl.html#abb5cf8330ab00e80d44513e3c4477418">getReps</a> (global float8 *in, global float8 *out)</td></tr>
<tr class="memdesc:abb5cf8330ab00e80d44513e3c4477418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Samples a set of landmarks for representatives.  <a href="#abb5cf8330ab00e80d44513e3c4477418">More...</a><br /></td></tr>
<tr class="separator:abb5cf8330ab00e80d44513e3c4477418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b122543dfc9fda04100ae1b168aaf7"><td class="memItemLeft" align="right" valign="top">kernel void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icp__kernels_8cl.html#a40b122543dfc9fda04100ae1b168aaf7">icpComputeReduceWeights</a> (global <a class="el" href="structdist__id.html">dist_id</a> *in, global float *weights, global double *sums, local float *data, uint n)</td></tr>
<tr class="memdesc:a40b122543dfc9fda04100ae1b168aaf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a set of weights \( \{w_i = \frac{100}{100+\|x_i-x&#39;_i\|_p}\} \), and reduces them to get their sum, \( \sum^n_i{w_i} \).  <a href="#a40b122543dfc9fda04100ae1b168aaf7">More...</a><br /></td></tr>
<tr class="separator:a40b122543dfc9fda04100ae1b168aaf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60183624873dec402c22a3e1f0c4bb4a"><td class="memItemLeft" align="right" valign="top">kernel void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icp__kernels_8cl.html#a60183624873dec402c22a3e1f0c4bb4a">icpComputeReduceWeights_WG</a> (global <a class="el" href="structdist__id.html">dist_id</a> *in, global float *weights, global float *sums, local float *data, uint n)</td></tr>
<tr class="memdesc:a60183624873dec402c22a3e1f0c4bb4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a set of weights \( \{w_i = \frac{100}{100+\|x_i-x&#39;_i\|_p}\} \), and reduces them to get their sum, \( \sum^n_i{w_i} \).  <a href="#a60183624873dec402c22a3e1f0c4bb4a">More...</a><br /></td></tr>
<tr class="separator:a60183624873dec402c22a3e1f0c4bb4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe8ae6509d7585a6e7e5223b6382d53"><td class="memItemLeft" align="right" valign="top">kernel void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icp__kernels_8cl.html#a0fe8ae6509d7585a6e7e5223b6382d53">reduce_sum_fd</a> (global float4 *in, global double *out, local double *data, uint n)</td></tr>
<tr class="memdesc:a0fe8ae6509d7585a6e7e5223b6382d53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduce operation on the columns of an array.  <a href="#a0fe8ae6509d7585a6e7e5223b6382d53">More...</a><br /></td></tr>
<tr class="separator:a0fe8ae6509d7585a6e7e5223b6382d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7f66e3a5f6c725a24196d615ae076c"><td class="memItemLeft" align="right" valign="top">kernel void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icp__kernels_8cl.html#a4a7f66e3a5f6c725a24196d615ae076c">icpMean</a> (global float4 *F, global float4 *M, global float4 *mean, local float *data, uint n)</td></tr>
<tr class="memdesc:a4a7f66e3a5f6c725a24196d615ae076c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs reduce operations on arrays of 8-D points.  <a href="#a4a7f66e3a5f6c725a24196d615ae076c">More...</a><br /></td></tr>
<tr class="separator:a4a7f66e3a5f6c725a24196d615ae076c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa638e3bb721a32b33325367a59709412"><td class="memItemLeft" align="right" valign="top">kernel void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icp__kernels_8cl.html#aa638e3bb721a32b33325367a59709412">icpMean_Weighted</a> (global float4 *F, global float4 *M, global float4 *MEAN, global float *W, constant double *sum_w, local float *data, uint n)</td></tr>
<tr class="memdesc:aa638e3bb721a32b33325367a59709412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs reduce operations on arrays of 8-D points.  <a href="#aa638e3bb721a32b33325367a59709412">More...</a><br /></td></tr>
<tr class="separator:aa638e3bb721a32b33325367a59709412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc312dc386e0998db2d98912f6e947f2"><td class="memItemLeft" align="right" valign="top">kernel void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icp__kernels_8cl.html#acc312dc386e0998db2d98912f6e947f2">icpGMean</a> (global float4 *in, global float4 *out, local float *data, uint n)</td></tr>
<tr class="memdesc:acc312dc386e0998db2d98912f6e947f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduce operation on an array of 4-D points.  <a href="#acc312dc386e0998db2d98912f6e947f2">More...</a><br /></td></tr>
<tr class="separator:acc312dc386e0998db2d98912f6e947f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad75d20a92bd3120757143a17593de087"><td class="memItemLeft" align="right" valign="top">kernel void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icp__kernels_8cl.html#ad75d20a92bd3120757143a17593de087">icpSubtractMean</a> (global float4 *F, global float4 *M, global float4 *DF, global float4 *DM, constant float4 *mean)</td></tr>
<tr class="memdesc:ad75d20a92bd3120757143a17593de087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the deviations from the means of the fixed and moving sets of 8-D points.  <a href="#ad75d20a92bd3120757143a17593de087">More...</a><br /></td></tr>
<tr class="separator:ad75d20a92bd3120757143a17593de087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5560be0fc1b96fb0a84a71038d2c6ba"><td class="memItemLeft" align="right" valign="top">kernel void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icp__kernels_8cl.html#ab5560be0fc1b96fb0a84a71038d2c6ba">icpSijProducts</a> (global float4 *M, global float4 *F, global float *Sij, uint m, float c)</td></tr>
<tr class="memdesc:ab5560be0fc1b96fb0a84a71038d2c6ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces the products in the Sij elements of the S matrix.  <a href="#ab5560be0fc1b96fb0a84a71038d2c6ba">More...</a><br /></td></tr>
<tr class="separator:ab5560be0fc1b96fb0a84a71038d2c6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f5e9fbe16e7e69ad36161ef92fa07f"><td class="memItemLeft" align="right" valign="top">kernel void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icp__kernels_8cl.html#af3f5e9fbe16e7e69ad36161ef92fa07f">icpSijProducts_Weighted</a> (global float4 *M, global float4 *F, global float *W, global float *Sij, uint m, float c)</td></tr>
<tr class="memdesc:af3f5e9fbe16e7e69ad36161ef92fa07f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces the weighted products in the Sij elements of the S matrix.  <a href="#af3f5e9fbe16e7e69ad36161ef92fa07f">More...</a><br /></td></tr>
<tr class="separator:af3f5e9fbe16e7e69ad36161ef92fa07f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5dd0eef3f5288dc36183889e9668dd0"><td class="memItemLeft" align="right" valign="top">kernel void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icp__kernels_8cl.html#ac5dd0eef3f5288dc36183889e9668dd0">icpTransform_Quaternion</a> (global float4 *M, global float4 *tM, constant float4 *data)</td></tr>
<tr class="memdesc:ac5dd0eef3f5288dc36183889e9668dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a homogeneous transformation on a set of points, \( p = \left[ \begin{matrix} p_x &amp; p_y &amp; p_z &amp; 1 \end{matrix} \right]^T \) (or as a quaternion, \( \dot{p} = \left[ \begin{matrix} p_x &amp; p_y &amp; p_z &amp; 0 \end{matrix} \right]^T \)), using unit quaternions \( \dot{q} = (\omega, \mathcal{v}) = q_w + (q_x i + q_y j + q_z k) = \left[ \begin{matrix} q_x &amp; q_y &amp; q_z &amp; q_w \end{matrix} \right]^T \), where \( \dot{q}\cdot\dot{q}=1 \).  <a href="#ac5dd0eef3f5288dc36183889e9668dd0">More...</a><br /></td></tr>
<tr class="separator:ac5dd0eef3f5288dc36183889e9668dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e87992a1a6f98a4c21c5954f56cc8a5"><td class="memItemLeft" align="right" valign="top">kernel void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icp__kernels_8cl.html#a6e87992a1a6f98a4c21c5954f56cc8a5">icpTransform_Quaternion_2</a> (global float4 *M, global float4 *tM, constant float4 *data)</td></tr>
<tr class="memdesc:a6e87992a1a6f98a4c21c5954f56cc8a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a homogeneous transformation on a set of points, \( p = \left[ \begin{matrix} p_x &amp; p_y &amp; p_z &amp; 1 \end{matrix} \right]^T \) (or as a quaternion, \( \dot{p} = \left[ \begin{matrix} p_x &amp; p_y &amp; p_z &amp; 0 \end{matrix} \right]^T \)), using unit quaternions \( \dot{q} = q_w + q_x i + q_y j + q_z k = \left[ \begin{matrix} q_x &amp; q_y &amp; q_z &amp; q_w \end{matrix} \right]^T \), where \( \dot{q}\cdot\dot{q}=1 \).  <a href="#a6e87992a1a6f98a4c21c5954f56cc8a5">More...</a><br /></td></tr>
<tr class="separator:a6e87992a1a6f98a4c21c5954f56cc8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b89ea0b54d3f06185ca31300e6528cd"><td class="memItemLeft" align="right" valign="top">kernel void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icp__kernels_8cl.html#a2b89ea0b54d3f06185ca31300e6528cd">icpTransform_Matrix</a> (global float4 *M, global float4 *tM, constant float4 *T)</td></tr>
<tr class="memdesc:a2b89ea0b54d3f06185ca31300e6528cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a homogeneous transformation on a set of points.  <a href="#a2b89ea0b54d3f06185ca31300e6528cd">More...</a><br /></td></tr>
<tr class="separator:a2b89ea0b54d3f06185ca31300e6528cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543638d65955fe4c893226c8f59818b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icp__kernels_8cl.html#a543638d65955fe4c893226c8f59818b7">prod</a> (float4 *N, float4 *x, float4 *x_new)</td></tr>
<tr class="memdesc:a543638d65955fe4c893226c8f59818b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a matrix-vector product, \( x_{new}=Nx \).  <a href="#a543638d65955fe4c893226c8f59818b7">More...</a><br /></td></tr>
<tr class="separator:a543638d65955fe4c893226c8f59818b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9bad9362c9000df702b4ee6d70cf6a"><td class="memItemLeft" align="right" valign="top">kernel void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icp__kernels_8cl.html#a1d9bad9362c9000df702b4ee6d70cf6a">icpPowerMethod</a> (global float *Sij, global float4 *means, global float4 *Tk)</td></tr>
<tr class="memdesc:a1d9bad9362c9000df702b4ee6d70cf6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the quantities that represent the incremental development in the transformation estimation in iteration <code>k</code>.  <a href="#a1d9bad9362c9000df702b4ee6d70cf6a">More...</a><br /></td></tr>
<tr class="separator:a1d9bad9362c9000df702b4ee6d70cf6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Kernels for the <code>ICP</code> pipeline. </p>
<dl class="section author"><dt>Author</dt><dd>Nick Lamprianidis </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2015 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>The MIT License (MIT) </dd></dl>
<dl class="section user"><dt></dt><dd>Copyright (c) 2015 Nick Lamprianidis </dd></dl>
<dl class="section user"><dt></dt><dd>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: </dd></dl>
<dl class="section user"><dt></dt><dd>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. </dd></dl>
<dl class="section user"><dt></dt><dd>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a8d115c63e8e45d94ce44c4ec35c3448c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kernel void getLMs </td>
          <td>(</td>
          <td class="paramtype">global float4 *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">global float4 *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Samples a point cloud for landmarks. </p>
<p>Chooses landmarks at specific intervals in the x and y dimension. </p><dl class="section note"><dt>Note</dt><dd>16384 landmarks are extracted from the point cloud \( (640 \times 480) \). These landmarks come from a center area. 10% of the points around the cloud are ignored. </dd>
<dd>
From the center area \( (512 \times 384) \), points are sampled <code>1:4</code> in the x dimension and <code>1:3</code> in the y dimension. There is also an offset <code>1</code> in the x dimension and 1 in the y dimension. This creates an array \( (128 \times 128) \) of landmarks. </dd>
<dd>
Invalid points (zero coordinates) are going to be picked. Further processing is needed for those points to be discraded, if necessary. </dd>
<dd>
The <b>x</b> dimension of the global workspace, \( gXdim \), should be equal to two times the number of landmarks per row (2 work-items per landmark). That is, \( \ gXdim=256 \). The <b>y</b> dimension of the global workspace, \( gYdim \), should be equal to the number of landmarks per column. That is, \( \ gYdim=128 \). There is no requirement for the local workspace.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>array (point cloud) of <code>float8</code> elements. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>array (landmarks) of <code>float8</code> elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abb5cf8330ab00e80d44513e3c4477418"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kernel void getReps </td>
          <td>(</td>
          <td class="paramtype">global float8 *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">global float8 *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Samples a set of landmarks for representatives. </p>
<p>Chooses representatives at specific intervals in the x and y dimension. </p><dl class="section note"><dt>Note</dt><dd>Representatives are extracted from the set of landmarks \( (128 \times 128) \). </dd>
<dd>
Representatives are sampled \( 1:(128/n_{rx}) \) in the x dimension and \( 1:(128/n_{ry}) \) in the y dimension. There is also an offset \( (128/n_{rx})/2-1 \) in the x dimension and \( (128/n_{ry})/2-1 \) in the y dimension. This creates an array \( (n_{rx} \times n_{ry}) \) of representatives. </dd>
<dd>
The <b>x</b> dimension of the global workspace, \( gXdim \), should be equal to the number of representatives per row. That is, \( \ gXdim=n_{rx }\). The <b>y</b> dimension of the global workspace, \( gYdim \), should be equal to the number of representatives per column. That is, \( \ gYdim=n_{ry} \). There is no requirement for the local workspace.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>array (landmarks) of <code>float8</code> elements. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>array (representatives) of <code>float8</code> elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a40b122543dfc9fda04100ae1b168aaf7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kernel void icpComputeReduceWeights </td>
          <td>(</td>
          <td class="paramtype">global <a class="el" href="structdist__id.html">dist_id</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">global float *&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">global double *&#160;</td>
          <td class="paramname"><em>sums</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">local float *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a set of weights \( \{w_i = \frac{100}{100+\|x_i-x&#39;_i\|_p}\} \), and reduces them to get their sum, \( \sum^n_i{w_i} \). </p>
<p>Takes distances between pairs of points and produces a set of weights. </p><dl class="section note"><dt>Note</dt><dd>The number of elements in the input array, <code>n</code>, should be a <b>multiple of 2</b>. The global workspace should be one dimensional, and its <b>x</b> dimension, \( gXdim \), should be greater than or equal to the number of elements in the array, <code>n</code>, divided by 2. That is, \( \ gXdim \geq n/2 \). Each work-item handles <code>2 <a class="el" href="structdist__id.html" title="Struct holding a value and a key. ">dist_id</a></code> elements. The local workspace should be one dimensional, and its <b>x</b> dimension should be a <b>power of 2</b>. It is recommended to use one <code>wavefront/warp</code> per work-group. </dd>
<dd>
The kernel is aimed to be used when the number of elements in the array is small enough to be handled by a single work-group. It promotes the output data type to <code>double</code> so that a consistent API is maintained.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>array of <code><a class="el" href="structdist__id.html" title="Struct holding a value and a key. ">dist_id</a></code> elements. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">weights</td><td>array with the computed weights (<code>float</code> elements). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sums</td><td>(reduced) array with the sum. Its size should be \( sizeof\ (double) \). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>local buffer. Its size should be <code>2 float</code> elements for each work-item in a work-group. That is \( 2*lXdim*sizeof\ (float) \). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of elements in the array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a60183624873dec402c22a3e1f0c4bb4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kernel void icpComputeReduceWeights_WG </td>
          <td>(</td>
          <td class="paramtype">global <a class="el" href="structdist__id.html">dist_id</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">global float *&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">global float *&#160;</td>
          <td class="paramname"><em>sums</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">local float *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a set of weights \( \{w_i = \frac{100}{100+\|x_i-x&#39;_i\|_p}\} \), and reduces them to get their sum, \( \sum^n_i{w_i} \). </p>
<p>Takes distances between pairs of points and produces a set of weights. </p><dl class="section note"><dt>Note</dt><dd>The number of elements in the input array, <code>n</code>, should be a <b>multiple of 2</b>. The global workspace should be one dimensional, and its <b>x</b> dimension, \( gXdim \), should be greater than or equal to the number of elements in the array, <code>n</code>, divided by 2. That is, \( \ gXdim \geq n/2 \). Each work-item handles <code>2 <a class="el" href="structdist__id.html" title="Struct holding a value and a key. ">dist_id</a></code> elements. The local workspace should be one dimensional, and its <b>x</b> dimension should be a <b>power of 2</b>. It is recommended to use one <code>wavefront/warp</code> per work-group. </dd>
<dd>
When the number of elements is small enough to be handled by a single work-group, use <code>icpComputeReduceWeights</code> instead. </dd>
<dd>
When the elements are more than what a single work-group can handle, they are partitioned into blocks and reduced independently. In this case, the kernel outputs the sum from each block reduction. A reduction should then be made (by <code>reduce_sum_fd</code>) on those sums for the final result. The number of work-groups in the <b>x</b> dimension, \( wgXdim \), <b>for the case of multiple work-groups</b>, should be made a <b>multiple of 4</b>. The potential extra work-groups are used for enforcing correctness. They write the necessary identity operands, <code>0.f</code>, in the output array, since in the next phase the data are going to be handled as <code>float4</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>array of <code><a class="el" href="structdist__id.html" title="Struct holding a value and a key. ">dist_id</a></code> elements. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">weights</td><td>array with the computed weights (<code>float</code> elements). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sums</td><td>(reduced) array with the sums. Its size should be \( wgXdim*sizeof\ (float) \). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>local buffer. Its size should be <code>2 float</code> elements for each work-item in a work-group. That is \( 2*lXdim*sizeof\ (float) \). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of elements in the array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acc312dc386e0998db2d98912f6e947f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kernel void icpGMean </td>
          <td>(</td>
          <td class="paramtype">global float4 *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">global float4 *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">local float *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a reduce operation on an array of 4-D points. </p>
<p>Computes the sums \( \bar{x}_j = \sum^{n}_{i}{x_{ij}}, j=\{0,1,2\} \) on the xyz dimensions of the points in the fixed and moving sets. </p><dl class="section note"><dt>Note</dt><dd>This kernel is supposed to be used for the reduction of the block means from <code>icpMean</code>. </dd>
<dd>
The global workspace should be one dimensional and its <b>x</b> dimension, \( gXdim \), should be greater or equal to the number of points, <code>n</code>, in the array divided by 2. That is, \( \ gXdim \geq n/2 \). The local workspace should also be one dimensional, and its <b>x</b> dimension should be a <b>power of 2</b>. It is recommended to use one <code>wavefront/warp</code> per work-group. </dd>
<dd>
When the number of points in the array is small enough to be handled by a single work-group, the output array will contain the true means. When the points are more than that, they are partitioned into blocks and reduced independently. In this case, the kernel outputs the means from each block reduction. A reduction should then be made on those means for the final result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>array of <code>float4</code> elements. The first 3 dimensions should contain the xyz coordinates of the points. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>array of mean <code>float4</code> vectors. When the kernel is dispatched with just one work-group, the array contains one vector with the means on the xyz dimensions, and its size should be \( sizeof\ (float4) \). When the kernel is dispatched with more than one work-group, the array contains the means from each block reduction, and its size should be \( wgXdim*sizeof\ (float4) \). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>local buffer. Its size should be <code>6 float</code> elements for each work-item in a work-group. That is \( lXdim*(2*(3*sizeof\ (float))) \). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of points in the array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4a7f66e3a5f6c725a24196d615ae076c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kernel void icpMean </td>
          <td>(</td>
          <td class="paramtype">global float4 *&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">global float4 *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">global float4 *&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">local float *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs reduce operations on arrays of 8-D points. </p>
<p>Computes the means \( \bar{x}_j = \sum^{n}_{i}{\frac{x_{ij}}{n}}, j=\{0,1,2\} \) on the xyz dimensions of the points in the fixed and moving sets. </p><dl class="section note"><dt>Note</dt><dd>The kernel normalizes the data, and then performs the reduction. </dd>
<dd>
The number of elements, <code>n</code>, in the arrays should be a <b>multiple of 2</b> (each work-item loads 2 points). The <b>x</b> dimension of the global workspace, \( gXdim \), should be greater than or equal to the number of points in the arrays divided by 2. That is, \( \ gXdim \geq n/2 \). The <b>y</b> dimension of the global workspace, \( gYdim \), should be equal to 2. That is, \( \ gYdim = 2 \). The local workspace should also be one dimensional, and its <b>x</b> dimension should be a <b>power of 2</b>. It is recommended to use one <code>wavefront/warp</code> per work-group. </dd>
<dd>
When the number of points in the arrays is small enough to be handled by a single work-group, the output arrays will contain the true means. When the points are more than that, they are partitioned into blocks and reduced independently. In this case, the kernel outputs the means from each block reduction. A reduction should then be made on those means for the final result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>fixed set of <code>float8</code> elements. The first 3 dimensions should contain the xyz coordinates of the points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>moving set of <code>float8</code> elements. The first 3 dimensions should contain the xyz coordinates of the points. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mean</td><td>array of mean <code>float4</code> vectors. When the kernel is dispatched with just one work-group per row, the array contains one vector per set with the means on the xyz dimensions. Its size should be \( 2*sizeof\ (float4) \). The first <code>float4</code> is the mean for the fixed set, and the second <code>float4</code> is the mean for the moving set. When the kernel is dispatched with more than one work-group, the array contains the means from each block reduction, and its size should be \( 2*(wgXdim*sizeof\ (float4)) \). The first row contains the block means for the fixed set, and the second row contains the block means for the moving set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>local buffer. Its size should be <code>6 float</code> elements for each work-item in a work-group. That is \( lXdim*(2*(3*sizeof\ (float))) \). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of points in the sets. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa638e3bb721a32b33325367a59709412"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kernel void icpMean_Weighted </td>
          <td>(</td>
          <td class="paramtype">global float4 *&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">global float4 *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">global float4 *&#160;</td>
          <td class="paramname"><em>MEAN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">global float *&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">constant double *&#160;</td>
          <td class="paramname"><em>sum_w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">local float *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs reduce operations on arrays of 8-D points. </p>
<p>Computes the weighted means \( \bar{x}_j = \frac{\sum^{n}_{i}{w_i*x_{ij}}} {\sum^{n}_{i}{w_i}}, j=\{0,1,2\} \) on the xyz dimensions of the points in the fixed and moving sets. </p><dl class="section note"><dt>Note</dt><dd>The kernel normalizes the data, and then performs the reduction. </dd>
<dd>
The number of elements, <code>n</code>, in the arrays should be a <b>multiple of 2</b> (each work-item loads 2 points). The <b>x</b> dimension of the global workspace, \( gXdim \), should be greater than or equal to the number of points in the arrays divided by 2. That is, \( \ gXdim \geq n/2 \). The <b>y</b> dimension of the global workspace, \( gYdim \), should be equal to 2. That is, \( \ gYdim = 2 \). The local workspace should also be one dimensional, and its <b>x</b> dimension should be a <b>power of 2</b>. It is recommended to use one <code>wavefront/warp</code> per work-group. </dd>
<dd>
When the number of points in the arrays is small enough to be handled by a single work-group, the output arrays will contain the true means. When the points are more than that, they are partitioned into blocks and reduced independently. In this case, the kernel outputs the means from each block reduction. A reduction should then be made on those means for the final result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>fixed set of <code>float8</code> elements. The first 3 dimensions should contain the xyz coordinates of the points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>moving set of <code>float8</code> elements. The first 3 dimensions should contain the xyz coordinates of the points. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">MEAN</td><td>array of mean <code>float4</code> vectors. When the kernel is dispatched with just one work-group per row, the array contains one vector per set with the means on the xyz dimensions. Its size should be \( 2*sizeof\ (float4) \). The first <code>float4</code> is the mean for the fixed set, and the second <code>float4</code> is the mean for the moving set. When the kernel is dispatched with more than one work-group, the array contains the means from each block reduction, and its size should be \( 2*(wgXdim*sizeof\ (float4)) \). The first row contains the block means for the fixed set, and the second row contains the block means for the moving set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">W</td><td>array with the weights between the pairs of points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sum_w</td><td>sum of the weights. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>local buffer. Its size should be <code>6 float</code> elements for each work-item in a work-group. That is \( lXdim*(2*(3*sizeof\ (float))) \). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of points in the sets. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1d9bad9362c9000df702b4ee6d70cf6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kernel void icpPowerMethod </td>
          <td>(</td>
          <td class="paramtype">global float *&#160;</td>
          <td class="paramname"><em>Sij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">global float4 *&#160;</td>
          <td class="paramname"><em>means</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">global float4 *&#160;</td>
          <td class="paramname"><em>Tk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the quantities that represent the incremental development in the transformation estimation in iteration <code>k</code>. </p>
<p>Uses the <code>Power Method</code> to estimate the unit quaternion \( q_k \) that represents the rotation, and then computes the scale \( s_k \) and translation \( t_k \). </p><dl class="section note"><dt>Note</dt><dd>The Power Method is performed on \(N\) and computes the eigenvector corresponding to the maximum magnitude eigenvalue \( \mu \). The eigenvector of interest is the one corresponding to the most positive eigenvalue \(\lambda\). If \( \mu&lt;0 \), the algorithm is executed again on \( N&#39;=N + |\lambda| I \). Then, the eigenvalue \( \lambda \) is \( \mu&#39; - \mu \). The corresponding eigenvector doesn't change. </dd>
<dd>
The kernel should be dispatched as a task (1 work-item).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Sij</td><td>array (sums of products) of size \(11*sizeof\ (float)\). The first <code>9</code> elements (in row major order) are the \(S_k\) matrix, and the next <code>2</code> are the numerator and denominator of the scale \(s_k\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">means</td><td>array (fixed and moving set means) of size \(2*sizeof\ (float4)\). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Tk</td><td>array of size \( 2 * sizeof\ (float4) \). The first <code>float4</code> is the <b>unit quaternion</b> \( \dot{q_k} = q_w + q_x i + q_y j + q_z k = \left[ \begin{matrix} q_x &amp; q_y &amp; q_z &amp; q_w \end{matrix} \right]^T \), and the second one is the <b>translation vector</b> \( t_k=\left[ \begin{matrix} t_x &amp; t_y &amp; t_z &amp; 1 \end{matrix} \right]^T \). The scale is placed in the last element of the translation vector. That is, \( t_k = \left[ \begin{matrix} t_x &amp; t_y &amp; t_z &amp; s_k \end{matrix} \right]^T \). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab5560be0fc1b96fb0a84a71038d2c6ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kernel void icpSijProducts </td>
          <td>(</td>
          <td class="paramtype">global float4 *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">global float4 *&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">global float *&#160;</td>
          <td class="paramname"><em>Sij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produces the products in the Sij elements of the S matrix. </p>
<p>Multiplies the deviations of corresponding points in the fixed set \( \mathcal{F}_{m \times 3} \) and the moving set \( \mathcal{M}_{m \times 3} \). </p><dl class="section note"><dt>Note</dt><dd>Since large sums of built, there is an option to scale the points in order to deal with floating point arithmetic issues. The resulting S matrix will have accordingly scaled eigenvalues. The eigenvectors stay the same. The constituents of the scaling factor s are scaled as well, but the factor itself is not affected. </dd>
<dd>
Each work-item processes up to 4 pairs of points. So, the output of each work-item is partial sums of products. On a next step, these results will have to be reduced to get the final S matrix. </dd>
<dd>
The global workspace should be one dimensional and its <b>x</b> dimension, \( gXdim \), should be greater or equal to the number of points, <code>m</code>, in the sets. That is, \( \ gXdim \geq m \). There is no requirement for the local workspace.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>array (moving set deviations) of <code>float4</code> elements. The first 3 dimensions should contain the xyz coordinates of the points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>array (fixed set deviations) of <code>float4</code> elements. The first 3 dimensions should contain the xyz coordinates of the points. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Sij</td><td>array (partial sums of products). Its number of rows is <code>11</code>. Its number of columns is \( gXdim \). So, its size should be \( 11 * gXdim * sizeof\ (float) \). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>number of points in the sets. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>scaling factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af3f5e9fbe16e7e69ad36161ef92fa07f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kernel void icpSijProducts_Weighted </td>
          <td>(</td>
          <td class="paramtype">global float4 *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">global float4 *&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">global float *&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">global float *&#160;</td>
          <td class="paramname"><em>Sij</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produces the weighted products in the Sij elements of the S matrix. </p>
<p>Multiplies the deviations of corresponding points in the fixed set \( \mathcal{F}_{m \times 3} \) and the moving set \( \mathcal{M}_{m \times 3} \). </p><dl class="section note"><dt>Note</dt><dd>Since large sums of built, there is an option to scale the points in order to deal with floating point arithmetic issues. The resulting S matrix will have accordingly scaled eigenvalues. The eigenvectors stay the same. The constituents of the scaling factor s are scaled as well, but the factor itself is not affected. </dd>
<dd>
Each work-item processes up to 4 pairs of points. So, the output of each work-item is partial sums of products. On a next step, these results will have to be reduced to get the final S matrix. </dd>
<dd>
The global workspace should be one dimensional and its <b>x</b> dimension, \( gXdim \), should be greater or equal to the number of points, <code>m</code>, in the sets. That is, \( \ gXdim \geq m \). There is no requirement for the local workspace.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>array (moving set deviations) of <code>float4</code> elements. The first 3 dimensions should contain the xyz coordinates of the points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>array (fixed set deviations) of <code>float4</code> elements. The first 3 dimensions should contain the xyz coordinates of the points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">W</td><td>array (weights) of <code>float</code> elements. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Sij</td><td>array (partial sums of products). Its number of rows is <code>11</code>. Its number of columns is \( gXdim \). So, its size should be \( 11 * gXdim * sizeof\ (float) \). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>number of points in the sets. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>scaling factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad75d20a92bd3120757143a17593de087"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kernel void icpSubtractMean </td>
          <td>(</td>
          <td class="paramtype">global float4 *&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">global float4 *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">global float4 *&#160;</td>
          <td class="paramname"><em>DF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">global float4 *&#160;</td>
          <td class="paramname"><em>DM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">constant float4 *&#160;</td>
          <td class="paramname"><em>mean</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the deviations from the means of the fixed and moving sets of 8-D points. </p>
<p>Subtracts the means from the 4-D geometric coordinates of the points. </p><dl class="section note"><dt>Note</dt><dd>The <b>x</b> dimension of the global workspace, \( gXdim \), should be equal to the number of points in the sets. That is, \( \ gXdim=n \). The <b>y</b> dimension of the global workspace should be equal to 2. That is, \( \ gYdim=2 \). There is no requirement for the local workspace.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>fixed set of <code>float8</code> elements. The first 3 dimensions should contain the xyz coordinates of the points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>moving set of <code>float8</code> elements. The first 3 dimensions should contain the xyz coordinates of the points. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DF</td><td>array of <code>float4</code> elements (fixed set deviations from the mean). Only the geometric information gets transfered in the output. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DM</td><td>array of <code>float4</code> elements (moving set deviations from the mean). Only the geometric information gets transfered in the output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mean</td><td>fixed and moving set means. The first <code>float4</code> is the fixed set mean, amd the second <code>float</code> is the moving set mean. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2b89ea0b54d3f06185ca31300e6528cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kernel void icpTransform_Matrix </td>
          <td>(</td>
          <td class="paramtype">global float4 *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">global float4 *&#160;</td>
          <td class="paramname"><em>tM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">constant float4 *&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a homogeneous transformation on a set of points. </p>
<p>Transforms each point in a set, \( p&#39; = Tp = \left[ \begin{matrix} R&#39; &amp; t \\ 0 &amp; 1 \end{matrix} \right]\left[ \begin{matrix} p \\ 1 \end{matrix} \right] = \left[ \begin{matrix} sR &amp; t \\ 0 &amp; 1 \end{matrix} \right]\left[ \begin{matrix} p \\ 1 \end{matrix} \right] = sRp+t \). </p><dl class="section note"><dt>Note</dt><dd>It there is a need for <b>scaling</b>, the scaling factor should already be incorporated in the <b>rotation matrix</b>. </dd>
<dd>
The <b>x</b> dimension of the global workspace, \( gXdim \), should be equal to 2. That is, \( \ gXdim = 2 \). The <b>y</b> dimension of the global workspace should be equal to the number of points, <code>m</code>, in the sets. That is, \( \ gYdim = m \). There is no requirement for the local workspace.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>array of <code>float8</code> elements. The first 4 dimensions should contain the homogeneous coordinates of the points. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tM</td><td>array of <code>float8</code> elements. The first 4 dimensions will contain the transformed homogeneous coordinates of the points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>the transformation matrix of size \( 16 * sizeof\ (float) \). The elements should be laid out in row major order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac5dd0eef3f5288dc36183889e9668dd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kernel void icpTransform_Quaternion </td>
          <td>(</td>
          <td class="paramtype">global float4 *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">global float4 *&#160;</td>
          <td class="paramname"><em>tM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">constant float4 *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a homogeneous transformation on a set of points, \( p = \left[ \begin{matrix} p_x &amp; p_y &amp; p_z &amp; 1 \end{matrix} \right]^T \) (or as a quaternion, \( \dot{p} = \left[ \begin{matrix} p_x &amp; p_y &amp; p_z &amp; 0 \end{matrix} \right]^T \)), using unit quaternions \( \dot{q} = (\omega, \mathcal{v}) = q_w + (q_x i + q_y j + q_z k) = \left[ \begin{matrix} q_x &amp; q_y &amp; q_z &amp; q_w \end{matrix} \right]^T \), where \( \dot{q}\cdot\dot{q}=1 \). </p>
<p>Transforms each point in a set, \(\ p&#39; = s\dot{q}\dot{p}\dot{q}^*+t = s(p + 2\mathcal{v} \times (\mathcal{v} \times p + \omega p)) + t \). </p><dl class="section note"><dt>Note</dt><dd>The <b>x</b> dimension of the global workspace, \( gXdim \), should be equal to 2. That is, \( \ gXdim = 2 \). The <b>y</b> dimension of the global workspace should be equal to the number of points, <code>m</code>, in the sets. That is, \( \ gYdim = m \). There is no requirement for the local workspace.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>array of <code>float8</code> elements. The first 4 dimensions should contain the homogeneous coordinates of the points. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tM</td><td>array of <code>float8</code> elements. The first 4 dimensions will contain the transformed homogeneous coordinates of the points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>array of size \( 2 * sizeof\ (float4) \). The first <code>float4</code> is the <b>quaternion</b>, and the second is the <b>translation vector</b>. If there is a need to apply <b>scaling</b>, the factor should be available in the last element of the translation vector. That is, \( t = \left[ \begin{matrix} t_x &amp; t_y &amp; t_z &amp; s \end{matrix} \right]^T \). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6e87992a1a6f98a4c21c5954f56cc8a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kernel void icpTransform_Quaternion_2 </td>
          <td>(</td>
          <td class="paramtype">global float4 *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">global float4 *&#160;</td>
          <td class="paramname"><em>tM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">constant float4 *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a homogeneous transformation on a set of points, \( p = \left[ \begin{matrix} p_x &amp; p_y &amp; p_z &amp; 1 \end{matrix} \right]^T \) (or as a quaternion, \( \dot{p} = \left[ \begin{matrix} p_x &amp; p_y &amp; p_z &amp; 0 \end{matrix} \right]^T \)), using unit quaternions \( \dot{q} = q_w + q_x i + q_y j + q_z k = \left[ \begin{matrix} q_x &amp; q_y &amp; q_z &amp; q_w \end{matrix} \right]^T \), where \( \dot{q}\cdot\dot{q}=1 \). </p>
<p>Transforms each point in a set, \(\ p&#39; = s\dot{q}\dot{p}\dot{q}^*+t = s\bar{Q}^TQ\dot{p}+t = s \left[ \begin{matrix} q_w &amp; q_z &amp; -q_y &amp; q_x \\ -q_z &amp; q_w &amp; q_x &amp; q_y \\ q_y &amp; -q_x &amp; q_w &amp; q_z \\ -q_x &amp; -q_y &amp; -q_z &amp; q_w \end{matrix} \right]^T \left[ \begin{matrix} q_w &amp; -q_z &amp; q_y &amp; q_x \\ q_z &amp; q_w &amp; -q_x &amp; q_y \\ -q_y &amp; q_x &amp; q_w &amp; q_z \\ -q_x &amp; -q_y &amp; -q_z &amp; q_w \end{matrix} \right] \left[ \begin{matrix} p_x \\ p_y \\ p_z \\ 0 \end{matrix} \right] + \left[ \begin{matrix} t_x \\ t_y \\ t_z \\ 1 \end{matrix} \right] = s \left[ \begin{matrix} 1-2q_y^2-2q_z^2 &amp; 2(q_xq_y-q_zq_w) &amp; 2(q_xq_z+q_yq_w) &amp; 0 \\ 2(q_xq_y+q_zq_w) &amp; 1-2q_x^2-2q_z^2 &amp; 2(q_yq_z-q_xq_w) &amp; 0 \\ 2(q_xq_z-q_yq_w) &amp; 2(q_yq_z+q_xq_w) &amp; 1-2q_x^2-2q_y^2 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{matrix} \right] \left[ \begin{matrix} p_x \\ p_y \\ p_z \\ 0 \end{matrix} \right] + \left[ \begin{matrix} t_x \\ t_y \\ t_z \\ 1 \end{matrix} \right]\). </p><dl class="section note"><dt>Note</dt><dd>The <b>x</b> dimension of the global workspace, \( gXdim \), should be equal to 2. That is, \( \ gXdim = 2 \). The <b>y</b> dimension of the global workspace should be equal to the number of points, <code>m</code>, in the sets. That is, \( \ gYdim = m \). There is no requirement for the local workspace.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>array of <code>float8</code> elements. The first 4 dimensions should contain the homogeneous coordinates of the points. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tM</td><td>array of <code>float8</code> elements. The first 4 dimensions will contain the transformed homogeneous coordinates of the points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>array of size \( 2 * sizeof\ (float4) \). The first <code>float4</code> is the <b>quaternion</b>, and the second is the <b>translation vector</b>. If there is a need to apply <b>scaling</b>, the factor should be available in the last element of the translation vector. That is, \( t = \left[ \begin{matrix} t_x &amp; t_y &amp; t_z &amp; s \end{matrix} \right]^T \). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a543638d65955fe4c893226c8f59818b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void prod </td>
          <td>(</td>
          <td class="paramtype">float4 *&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float4 *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float4 *&#160;</td>
          <td class="paramname"><em>x_new</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a matrix-vector product, \( x_{new}=Nx \). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><code>4x4</code> matrix (<code>4xfloat4</code> elements). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>vector (<code>float4</code> element). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">x_new</td><td>vector (<code>float4</code> element). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0fe8ae6509d7585a6e7e5223b6382d53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kernel void reduce_sum_fd </td>
          <td>(</td>
          <td class="paramtype">global float4 *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">global double *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">local double *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a reduce operation on the columns of an array. </p>
<p>Computes the sum of the elements of each row in an array. </p><dl class="section note"><dt>Note</dt><dd>When there are multiple rows in the array, a reduce operation is performed per row, in parallel. </dd>
<dd>
The number of elements, <code>N</code>, in a row of the array should be a <b>multiple of 4</b> (the data are handled as <code>float4</code>). The <b>x</b> dimension of the global workspace, \( gXdim \), should be greater or equal to the number of elements in a row of the array divided by 8. That is, \( \ gXdim \geq N/8 \). Each work-item handles <code>8 float</code> (= <code>2 float4</code>) elements in a row of the array. The <b>y</b> dimension of the global workspace, \( gYdim \), should be equal to the number of rows, <code>M</code>, in the array. That is, \( \ gYdim = M \). The local workspace should be <code>1</code> in the <b>y</b> dimension, and a <b>power of 2</b> in the <b>x</b> dimension. It is recommended to use one <code>wavefront/warp</code> per work-group. </dd>
<dd>
When the number of elements per row of the array is small enough to be handled by a single work-group, the output array will contain the true sums. When the elements are more than that, they are partitioned into blocks and reduced independently. In this case, the kernel outputs the sum from each block reduction. A reduction should then be made on those sums for the final results. The number of work-groups in the <b>x</b> dimension, \( wgXdim \), <b>for the case of multiple work-groups</b>, should be made a <b>multiple of 4</b>. The potential extra work-groups are used for enforcing correctness. They write the necessary identity operands, <code>0.0</code>, in the output array, since in the next phase the data are going to be handled as <code>double4</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>array of <code>float</code> elements. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>(reduced) array of <code>double</code> elements. When the kernel is dispatched with one work-group per row, the array contains the final results, and its size should be \( rows*sizeof\ (double) \). When the kernel is dispatched with more than one work-groups per row, the array contains the results from each block reduction, and its size should be \( wgXdim*rows*sizeof\ (double) \). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>local buffer. Its size should be <code>2 double</code> elements for each work-item in a work-group. That is \( 2*lXdim*sizeof\ (double) \). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of elements in a row of the array divided by 4. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jun 17 2015 01:04:50 for ICP by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
